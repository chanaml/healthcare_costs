{"version":3,"file":"ckmeans.js","sources":["../../src/ckmeans.js"],"sourcesContent":["/**\n    @desc Sort an array of numbers by their numeric value, ensuring that the array is not changed in place.\n\nThis is necessary because the default behavior of .sort in JavaScript is to sort arrays as string values\n\n[1, 10, 12, 102, 20].sort()\n// output\n[1, 10, 102, 12, 20]\n\n    @param {Array<number>} array input array\n    @return {Array<number>} sorted array\n    @private\n    @example\nnumericSort([3, 2, 1]) // => [1, 2, 3]\n*/\nfunction numericSort(array) {\n  return array.slice().sort((a, b) => a - b);\n}\n\n/**\n    For a sorted input, counting the number of unique values is possible in constant time and constant memory. This is a simple implementation of the algorithm.\n\n    Values are compared with `===`, so objects and non-primitive objects are not handled in any special way.\n    @private\n    @param {Array} input an array of primitive values.\n    @returns {number} count of unique values\n    @example\nuniqueCountSorted([1, 2, 3]); // => 3\nuniqueCountSorted([1, 1, 1]); // => 1\n*/\nfunction uniqueCountSorted(input) {\n  let lastSeenValue, uniqueValueCount = 0;\n  for (let i = 0; i < input.length; i++) {\n    if (i === 0 || input[i] !== lastSeenValue) {\n      lastSeenValue = input[i];\n      uniqueValueCount++;\n    }\n  }\n  return uniqueValueCount;\n}\n\n/**\n    Create a new column x row matrix.\n    @private\n    @param {number} columns\n    @param {number} rows\n    @return {Array<Array<number>>} matrix\n    @example\nmakeMatrix(10, 10);\n*/\nfunction makeMatrix(columns, rows) {\n  const matrix = [];\n  for (let i = 0; i < columns; i++) {\n    const column = [];\n    for (let j = 0; j < rows; j++) column.push(0);\n    matrix.push(column);\n  }\n  return matrix;\n}\n\n/**\n    Generates incrementally computed values based on the sums and sums of squares for the data array\n    @private\n    @param {number} j\n    @param {number} i\n    @param {Array<number>} sums\n    @param {Array<number>} sumsOfSquares\n    @return {number}\n    @example\nssq(0, 1, [-1, 0, 2], [1, 1, 5]);\n*/\nfunction ssq(j, i, sums, sumsOfSquares) {\n  let sji; // s(j, i)\n\n  if (j > 0) {\n    const muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)\n    sji = sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;\n  }\n  else sji = sumsOfSquares[i] - sums[i] * sums[i] / (i + 1);\n\n  if (sji < 0) return 0;\n  return sji;\n}\n\n/**\n    Function that recursively divides and conquers computations for cluster j\n    @private\n    @param {number} iMin Minimum index in cluster to be computed\n    @param {number} iMax Maximum index in cluster to be computed\n    @param {number} cluster Index of the cluster currently being computed\n    @param {Array<Array<number>>} matrix\n    @param {Array<Array<number>>} backtrackMatrix\n    @param {Array<number>} sums\n    @param {Array<number>} sumsOfSquares\n*/\nfunction fillMatrixColumn(iMin, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares) {\n  if (iMin > iMax) return;\n\n  // Start at midpoint between iMin and iMax\n  const i = Math.floor((iMin + iMax) / 2);\n\n  matrix[cluster][i] = matrix[cluster - 1][i - 1];\n  backtrackMatrix[cluster][i] = i;\n\n  let jlow = cluster; // the lower end for j\n  if (iMin > cluster) jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);\n  jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);\n\n  let jhigh = i - 1; // the upper end for j\n  if (iMax < matrix.length - 1) jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);\n\n  for (let j = jhigh; j >= jlow; --j) {\n    const sji = ssq(j, i, sums, sumsOfSquares);\n\n    if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) break;\n\n    // Examine the lower bound of the cluster border\n    const sjlowi = ssq(jlow, i, sums, sumsOfSquares);\n\n    const ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];\n\n    if (ssqjlow < matrix[cluster][i]) {\n      // Shrink the lower bound\n      matrix[cluster][i] = ssqjlow;\n      backtrackMatrix[cluster][i] = jlow;\n    }\n    jlow++;\n\n    const ssqj = sji + matrix[cluster - 1][j - 1];\n    if (ssqj < matrix[cluster][i]) {\n      matrix[cluster][i] = ssqj;\n      backtrackMatrix[cluster][i] = j;\n    }\n  }\n\n  fillMatrixColumn(iMin, i - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n  fillMatrixColumn(i + 1, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n\n}\n\n/**\n    Initializes the main matrices used in Ckmeans and kicks off the divide and conquer cluster computation strategy\n    @private\n    @param {Array<number>} data sorted array of values\n    @param {Array<Array<number>>} matrix\n    @param {Array<Array<number>>} backtrackMatrix\n*/\nfunction fillMatrices(data, matrix, backtrackMatrix) {\n  const nValues = matrix[0].length;\n\n  // Shift values by the median to improve numeric stability\n  const shift = data[Math.floor(nValues / 2)];\n\n  // Cumulative sum and cumulative sum of squares for all values in data array\n  const sums = [];\n  const sumsOfSquares = [];\n\n  // Initialize first column in matrix & backtrackMatrix\n  for (let i = 0, shiftedValue; i < nValues; ++i) {\n    shiftedValue = data[i] - shift;\n    if (i === 0) {\n      sums.push(shiftedValue);\n      sumsOfSquares.push(shiftedValue * shiftedValue);\n    }\n    else {\n      sums.push(sums[i - 1] + shiftedValue);\n      sumsOfSquares.push(sumsOfSquares[i - 1] + shiftedValue * shiftedValue);\n    }\n\n    // Initialize for cluster = 0\n    matrix[0][i] = ssq(0, i, sums, sumsOfSquares);\n    backtrackMatrix[0][i] = 0;\n  }\n\n  // Initialize the rest of the columns\n  for (let cluster = 1; cluster < matrix.length; ++cluster) {\n    let iMin = nValues - 1;\n    if (cluster < matrix.length - 1) iMin = cluster;\n    fillMatrixColumn(iMin, nValues - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n  }\n}\n\n/**\n    @desc Ported to ES6 from the excellent [simple-statistics](https://github.com/simple-statistics/simple-statistics) packages.\n\nCkmeans clustering is an improvement on heuristic-based clustering approaches like Jenks. The algorithm was developed in [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf) as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach to the problem of clustering numeric data into groups with the least within-group sum-of-squared-deviations.\n\nMinimizing the difference within groups - what Wang & Song refer to as `withinss`, or within sum-of-squares, means that groups are optimally homogenous within and the data is split into representative groups. This is very useful for visualization, where you may want to represent a continuous variable in discrete color or style groups. This function can provide groups that emphasize differences between data.\n\nBeing a dynamic approach, this algorithm is based on two matrices that store incrementally-computed values for squared deviations and backtracking indexes.\n\nThis implementation is based on Ckmeans 3.4.6, which introduced a new divide and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).\n\nUnlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html), this implementation does not include any code to automatically determine the optimal number of clusters: this information needs to be explicitly provided.\n\n### References\n_Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\nProgramming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859 from The R Journal Vol. 3/2, December 2011\n    @param {Array<number>} data input data, as an array of number values\n    @param {number} nClusters number of desired classes. This cannot be greater than the number of values in the data array.\n    @returns {Array<Array<number>>} clustered input\n    @example\nckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n// The input, clustered into groups of similar numbers.\n//= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n*/\nexport default function(data, nClusters) {\n\n  if (nClusters > data.length) {\n    throw new Error(\"Cannot generate more classes than there are data values\");\n  }\n\n  const sorted = numericSort(data);\n\n  // we'll use this as the maximum number of clusters\n  const uniqueCount = uniqueCountSorted(sorted);\n\n  // if all of the input values are identical, there's one cluster with all of the input in it.\n  if (uniqueCount === 1) return [sorted];\n\n  const backtrackMatrix = makeMatrix(nClusters, sorted.length),\n        matrix = makeMatrix(nClusters, sorted.length);\n\n  // This is a dynamic programming way to solve the problem of minimizing within-cluster sum of squares. It's similar to linear regression in this way, and this calculation incrementally computes the sum of squares that are later read.\n  fillMatrices(sorted, matrix, backtrackMatrix);\n\n  // The real work of Ckmeans clustering happens in the matrix generation: the generated matrices encode all possible clustering combinations, and once they're generated we can solve for the best clustering groups very quickly.\n  let clusterRight = backtrackMatrix[0].length - 1;\n  const clusters = [];\n\n  // Backtrack the clusters from the dynamic programming matrix. This starts at the bottom-right corner of the matrix (if the top-left is 0, 0), and moves the cluster target with the loop.\n  for (let cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n\n    const clusterLeft = backtrackMatrix[cluster][clusterRight];\n\n    // fill the cluster from the sorted input by taking a slice of the array. the backtrack matrix makes this easy - it stores the indexes where the cluster should start and end.\n    clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n\n    if (cluster > 0) clusterRight = clusterLeft - 1;\n\n  }\n\n  return clusters;\n\n}\n"],"names":["let","const"],"mappings":"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"}