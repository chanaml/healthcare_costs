import assign from "./assign";
import isObject from "./isObject";
import uuid from "./uuid";
import RESET from "./RESET";

/**
    @desc Recursive function that resets nested Object configs.
    @param {Object} obj
    @param {Object} defaults
    @private
*/
function nestedReset(obj, defaults) {
  if (isObject(obj)) {
    for (var nestedKey in obj) {
      if ({}.hasOwnProperty.call(obj, nestedKey) && !nestedKey.startsWith("_")) {
        var defaultValue = defaults && isObject(defaults) ? defaults[nestedKey] : undefined;
        if (obj[nestedKey] === RESET) {
          obj[nestedKey] = defaultValue;
        }
        else if (isObject(obj[nestedKey])) {
          nestedReset(obj[nestedKey], defaultValue);
        }
      }
    }
  }
}

/**
    @class BaseClass
    @summary An abstract class that contains some global methods and functionality.
*/
var BaseClass = function BaseClass() {
  this._on = {};
  this._uuid = uuid();
};

/**
    @memberof BaseClass
    @desc If *value* is specified, sets the methods that correspond to the key/value pairs and returns this class. If *value* is not specified, returns the current configuration.
    @param {Object} [*value*]
    @chainable
*/
BaseClass.prototype.config = function config (_) {
    var this$1 = this;

  if (!this._configDefault) {
    var config = {};
    for (var k in this$1.__proto__) {
      if (k.indexOf("_") !== 0 && !["config", "constructor", "render"].includes(k)) {
        var v = this$1[k]();
        config[k] = isObject(v) ? assign({}, v) : v;
      }
    }
    this._configDefault = config;
  }
  if (arguments.length) {
    for (var k$1 in _) {
      if ({}.hasOwnProperty.call(_, k$1) && k$1 in this$1) {
        var v$1 = _[k$1];
        if (v$1 === RESET) {
          if (k$1 === "on") { this$1._on = this$1._configDefault[k$1]; }
          else { this$1[k$1](this$1._configDefault[k$1]); }
        }
        else {
          nestedReset(v$1, this$1._configDefault[k$1]);
          this$1[k$1](v$1);
        }
      }
    }
    return this;
  }
  else {
    var config$1 = {};
    for (var k$2 in this$1.__proto__) { if (k$2.indexOf("_") !== 0 && !["config", "constructor", "render"].includes(k$2)) { config$1[k$2] = this$1[k$2](); } }
    return config$1;
  }
};

/**
    @memberof BaseClass
    @desc Adds or removes a *listener* to each object for the specified event *typenames*. If a *listener* is not specified, returns the currently assigned listener for the specified event *typename*. Mirrors the core [d3-selection](https://github.com/d3/d3-selection#selection_on) behavior.
    @param {String} [*typenames*]
    @param {Function} [*listener*]
    @chainable
    @example <caption>By default, listeners apply globally to all objects, however, passing a namespace with the class name gives control over specific elements:</caption>
new Plot
.on("click.Shape", function(d) {
  console.log("data for shape clicked:", d);
})
.on("click.Legend", function(d) {
  console.log("data for legend clicked:", d);
})
*/
BaseClass.prototype.on = function on (_, f) {
  return arguments.length === 2 ? (this._on[_] = f, this) : arguments.length ? typeof _ === "string" ? this._on[_] : (this._on = Object.assign({}, this._on, _), this) : this._on;
};

export default BaseClass;

//# sourceMappingURL=BaseClass.js.map